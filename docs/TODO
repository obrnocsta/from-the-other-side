# Routes & Paths

## Intro (new)

**Our three main tasks:**

- Server assets
- Provide data via an API
- Add user input to our data

**Extra:**

- A section on events

**We will be studying:**

- The 'fs' module
  - reading/writing files
- The 'path' module
  - create file/directory paths

## Setting up the project

**Challenge:**

```bash
# 1. 
#   Initialise a nodejs project:
#   Name: “from-the-other-side”.
#   Description: “A platform for sharing ghostly encounters”.
# 2.
#   Enable modular js (in package.json).
```

**Hint for help:**

```bash
# In terminal:
npm init

# In package.json: 
"type": "module"
```

**Challenge:**

```bash
# 1.
#   Set up a server that serves the string 
#   '<html><h1>The server is working</h1></html>'.
#   What should the content type be? 
#   What status code should you send?

# 2. 
#   Listen on port 8000 and log a connection message to the console.

# 3. 
#   Open the browser to see your first served HTML.
```

## Rounting and serving data

- Identify what `resources` the client wants.
- Identify the `path` to that resources:
  - The current module's directory.
  - The path to the resource from that directory.
- Read the resources we want to serve using `fs module`.
- Send those resources to the client.

**Important:** We need to be OS agnostic!

**import-meta**: 

- Is an object specific to the modular JS enviroment, which provides metadata about the current module.

**Hint:**

```js
const __dirname = import.meta.dirname
```

## Aside: Path Module

**Relative paths created with Path Module:**

- Start from the `Current Working Directory` - CWD.
- Are therefore affected by changes to the CWD.
- That means they are not as safe, but sometimes more flexible.

**Hint:**

```js
// server.js
import path from 'node:path'
const __dirname = import.meta.dirname
// inside server callback function
const pathFile = path.join(__dirname, 'public', 'index.html')
```

## Get Path to Resource

**Challenge:**

```bash
# 1. 
#   Get the name of the directory holding this server.js file and store it to a const ‘__dirname’.
# 2.
#   Create and export a function called 'serveStatic'. 
#   It should take in the base directory as a parameter.
#   Build a path to index.html in the 'public' folder and save it to a const 'filePath'. 
#   (Which node module will you need to import to do this? Which method joins the path together?)
#   Log 'filePath' to the console.
# 3.
#   Import and call serveStatic and pass it the directory of this current module.
```

## Aside: FS Module

**FS Module uses:**

- Read files `readFile()`
- Create files `writeFile()`
- Update files `appendFIle()`
- Delete files `unlink()`
- Rename files `rename()`

```js
// server.js
import fs from 'node:fs/promises'
// inside server callback function
const content = await fs.readFile(pathFile)
```

## Server index.html

**Challenge:**

```js
// 1.
//   Store index.html as a buffer in a const ‘content’. 
//   As this is an async process, do this inside a try/catch block.
//   For now, just log the error in the catch block.
//   You will need to change something to do with the function declaration. What is it?

// 2.
//   Create and export a function called sendResponse().  
//   What 4 things should this function take in as parameters?

// 3.
//   Import sendResponse() and use it to serve index.html. 
//   Pass in all of the information sendResponse() is expecting.
//   serveStatic() will need another param. What is it?

//   Make any changes necessary in server.js and delete any unneeded code.
```

## Server the frontend

**Challenge:**

```bash
# 1. 
#   Write code below to serve files from our public directory.
#   Don’t worry about handling errors for now.
#   hint.md for help!
```

```js
// serveStatic.js
const publicDir = path.join(__dirname, 'public')
const pathResource = path.join(
  publicDir,
  req.url === '/' ? 'index.html' : req.url
)
// ...
const ext = path.extname(pathResource)
const contentType = getContentType(ext)
// ...
res.setHeader('Content-Type', contentType)
```

**Hint:**

```bash
# 2. 
#   To keep things neat, create a path to the 'public' folder.
#   Use a ternary to get the path to the file to serve (remember, a request to '/' is a request for index.html).
#   Get the extension from path's extname() method.
#   Use the extension to get the Content-Type from getContentType().
#   Pass sendResponse() the correct content-contentType.
#   Test.
```

```js
// getContentType.js
export const getContentType = (ext) => {
  const type = {
    '.js': 'text/javascript',
    '.css': 'text/css',
    '.json': 'application/json',
    '.png': 'image/png',
    '.jpg': 'image/jpeg',
    '.jpeg': 'image/jpeg',
    '.gif': 'image/gif',
    '.svg': 'image/svg+xml'
  }
  return types[ext.toLowerCase()] || 'text/html'
}
```

**Challenge:**

```bash
# 3.
#   If the error code is “ENOENT”, serve the 404.html page.  
#   If there’s another error, serve a 500 with this string: 
#   `<html><h1>Server Error: ${err.code}</h1></html>`. 

#   The Content-Type for the 500 can be ‘text/html’.
```

## Getting the JSON Data

**Challenge:**

```bash
# 1. 
#   getData() should: 
#     - read the json in json.data as a string 
#     - parse it to JS 
#     - return the parsed data. 

#   If there’s an error, it should return an empty array (think, why are we doing this?).
```
